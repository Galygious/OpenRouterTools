// Core classes for OpenRouter Dashboard
class AuthManager {
  constructor() {
    this.keyStorageKey = 'openrouter_api_key';
    this.init();
  }

  init() {
    const storedKey = this.getStoredKey();
    if (storedKey) {
      document.getElementById('api-key').value = storedKey;
      this.validateAndStoreKey(storedKey);
    }

    document.getElementById('save-key').addEventListener('click', () => {
      const key = document.getElementById('api-key').value.trim();
      this.validateAndStoreKey(key);
    });
  }

  async validateAndStoreKey(apiKey) {
    if (!apiKey) {
      this.showError('Please enter an API key');
      return false;
    }

    try {
      const response = await fetch('https://openrouter.ai/api/v1/auth/key', {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'HTTP-Referer': 'https://galygious.github.io/OpenRouterTools'
        }
      });

      if (response.ok) {
        localStorage.setItem(this.keyStorageKey, apiKey);
        this.showSuccess('API key validated and saved');
        return true;
      } else {
        this.showError('Invalid API key');
        return false;
      }
    } catch (error) {
      this.showError('Error validating API key');
      return false;
    }
  }

  getStoredKey() {
    return localStorage.getItem(this.keyStorageKey);
  }

  showError(message) {
    const errorMessage = document.getElementById('error-message');
    errorMessage.textContent = message;
    errorMessage.style.color = '#dc3545';
  }

  showSuccess(message) {
    const errorMessage = document.getElementById('error-message');
    errorMessage.textContent = message;
    errorMessage.style.color = '#28a745';
  }
}

class ProviderSelector {
  constructor(providers = []) {
    this.providers = providers;
    this.sortCriteria = 'price';
  }

  setProviders(providers) {
    this.providers = providers;
  }

  rankProviders(criteria = this.sortCriteria) {
    this.sortCriteria = criteria;
    return [...this.providers].sort((a, b) => {
      switch(criteria) {
        case 'price':
          return (a.pricing?.prompt || 0) - (b.pricing?.prompt || 0);
        case 'latency':
          return (a.stats?.[0]?.avg_latency || 0) - (b.stats?.[0]?.avg_latency || 0);
        case 'throughput':
          return (b.stats?.[0]?.throughput || 0) - (a.stats?.[0]?.throughput || 0);
        default:
          return 0;
      }
    });
  }

  selectBestProvider(constraints = {}) {
    const { maxPrice, maxLatency } = constraints;
    const ranked = this.rankProviders(this.sortCriteria);
    
    // Convert maxPrice from dollars per million tokens to raw price
    const maxPriceRaw = maxPrice ? maxPrice / (10 ** 6) : null;
    
    return ranked.find(provider => {
      const promptPrice = provider.pricing?.prompt || 0;
      const completionPrice = provider.pricing?.completion || 0;
      const avgPrice = (promptPrice + completionPrice) / 2;
      const latency = provider.stats?.[0]?.avg_latency || 0;
      
      return (!maxPriceRaw || avgPrice <= maxPriceRaw) &&
             (!maxLatency || latency <= maxLatency);
    });
  }
}

class InferenceManager {
  constructor(authManager) {
    this.authManager = authManager;
    this.endpoint = 'https://openrouter.ai/api/v1/chat/completions';
  }

  async generateCompletion(prompt, model, provider) {
    const apiKey = this.authManager.getStoredKey();
    if (!apiKey) {
      throw new Error('API key not found');
    }

    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
        'HTTP-Referer': 'https://galygious.github.io/OpenRouterTools',
        'X-Title': 'OpenRouter Dashboard'
      },
      body: JSON.stringify({
        model: model,
        messages: [{ role: 'user', content: prompt }],
        stream: true,
        max_tokens: provider?.context_length || undefined,
        temperature: 0.7
      })
    });

    if (!response.ok) {
      throw new Error(`API error: ${response.statusText}`);
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let result = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = JSON.parse(line.slice(6));
          if (data.choices?.[0]?.delta?.content) {
            result += data.choices[0].delta.content;
            this.onProgress?.(result);
          }
        }
      }
    }

    return result;
  }

  calculateTokenUsage(prompt, response) {
    // Rough estimation: 1 token â‰ˆ 4 characters
    const promptTokens = Math.ceil(prompt.length / 4);
    const responseTokens = Math.ceil(response.length / 4);
    return {
      promptTokens,
      responseTokens,
      totalTokens: promptTokens + responseTokens
    };
  }
}

class UIManager {
  constructor(authManager, providerSelector, inferenceManager) {
    this.authManager = authManager;
    this.providerSelector = providerSelector;
    this.inferenceManager = inferenceManager;
    this.init();
  }

  init() {
    this.setupTabNavigation();
    this.setupModelSelector();
    this.setupProviderFilters();
    this.setupChatInterface();
  }

  setupTabNavigation() {
    const tabs = document.querySelectorAll('.tab-button');
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => {
          t.classList.remove('active');
          t.setAttribute('aria-pressed', 'false');
        });
        tab.classList.add('active');
        tab.setAttribute('aria-pressed', 'true');

        const targetId = tab.id.replace('-tab', '-view');
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(targetId).classList.add('active');
      });
    });
  }

  setupModelSelector() {
    const dropdown = document.getElementById('model-dropdown');
    dropdown.addEventListener('change', () => {
      const selectedModel = dropdown.value;
      if (selectedModel) {
        this.updateProviderList(selectedModel);
      }
    });
  }

  setupProviderFilters() {
    const filterButtons = document.querySelectorAll('#provider-filters button');
    filterButtons.forEach(button => {
      button.addEventListener('click', () => {
        filterButtons.forEach(b => b.classList.remove('active'));
        button.classList.add('active');
        this.providerSelector.sortCriteria = button.dataset.sort;
        this.updateProviderList(document.getElementById('model-dropdown').value);
      });
    });
  }

  setupChatInterface() {
    const sendButton = document.getElementById('send-prompt');
    const promptInput = document.getElementById('prompt-input');
    const maxPriceInput = document.getElementById('max-price');

    sendButton.addEventListener('click', async () => {
      const prompt = promptInput.value.trim();
      if (!prompt) return;

      const model = document.getElementById('model-dropdown').value;
      if (!model) {
        this.showError('Please select a model');
        return;
      }

      const maxPrice = maxPriceInput.value ? parseFloat(maxPriceInput.value) : null;
      const provider = this.providerSelector.selectBestProvider({ maxPrice });
      
      if (!provider) {
        this.showError('No provider available within the specified price limit');
        return;
      }

      try {
        sendButton.disabled = true;
        this.addMessage(prompt, 'user');
        promptInput.value = '';

        // Set up streaming response handler
        this.inferenceManager.onProgress = (partialResponse) => {
          const messageDiv = document.querySelector('.message.assistant:last-child');
          if (messageDiv) {
            messageDiv.textContent = partialResponse;
          } else {
            this.addMessage(partialResponse, 'assistant');
          }
        };

        const response = await this.inferenceManager.generateCompletion(
          prompt,
          model,
          provider
        );

        this.updateUsageStats(prompt, response);
      } catch (error) {
        this.showError(error.message);
      } finally {
        sendButton.disabled = false;
        this.inferenceManager.onProgress = null;
      }
    });

    promptInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendButton.click();
      }
    });
  }

  addMessage(content, role) {
    const messages = document.getElementById('messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${role}`;
    messageDiv.textContent = content;
    messages.appendChild(messageDiv);
    messages.scrollTop = messages.scrollHeight;
  }

  updateUsageStats(prompt, response) {
    const usage = this.inferenceManager.calculateTokenUsage(prompt, response);
    document.getElementById('token-count').textContent = 
      `Tokens: ${usage.totalTokens}`;
    
    // Estimate cost (using average rate of $0.000002 per token)
    const estimatedCost = usage.totalTokens * 0.000002;
    document.getElementById('cost-estimate').textContent = 
      `Est. Cost: $${estimatedCost.toFixed(6)}`;
  }

  showError(message) {
    const errorMessage = document.getElementById('error-message');
    errorMessage.textContent = message;
    errorMessage.style.color = '#dc3545';
  }

  async updateProviderList(modelName) {
    if (!modelName) return;
    
    try {
      const response = await fetch(
        `https://openrouter.ai/api/frontend/stats/endpoint?permaslug=${modelSlugs[modelName]}`
      );
      if (!response.ok) throw new Error('Failed to fetch providers');
      
      const data = await response.json();
      this.providerSelector.setProviders(data.data);
      const rankedProviders = this.providerSelector.rankProviders();
      
      // Update UI to show provider ranking if needed
    } catch (error) {
      this.showError('Error fetching providers: ' + error.message);
    }
  }
}

// Initialize existing stats functionality
let modelData = {};
let modelRecords = [];
let modelSlugs = {};

window.addEventListener('DOMContentLoaded', async () => {
  try {
    // Initialize core managers
    const authManager = new AuthManager();
    const providerSelector = new ProviderSelector();
    const inferenceManager = new InferenceManager(authManager);
    const uiManager = new UIManager(authManager, providerSelector, inferenceManager);

    // Initialize existing stats functionality
    const { nestedModel, allModelRecords } = await fetchModels();
    if (!nestedModel || !allModelRecords) {
      throw new Error('Failed to load models');
    }

    modelData = nestedModel;
    modelRecords = allModelRecords;

    // Populate model dropdown
    const dropdown = document.getElementById('model-dropdown');
    Object.keys(modelSlugs).forEach(modelName => {
      const option = document.createElement('option');
      option.value = modelName;
      option.textContent = modelName;
      dropdown.appendChild(option);
    });

    // Automatically fetch all stats on load
    const allModelNames = Object.values(modelRecords)
      .map(model => model.endpoint.model.name);
    if (allModelNames.length > 0) {
      fetchStatsForAllModels(allModelNames);
    }
  } catch (error) {
    console.error('Error during initialization:', error);
    document.getElementById('error-message').textContent =
      'Error loading AI models. Please refresh the page to try again.';
  }
});

// Existing stats functionality (unchanged)
async function fetchModels() {
  const API_URL = "https://openrouter.ai/api/frontend/models";
  const nestedModel = {};
  const allModelRecords = {};

  try {
    const response = await fetch(API_URL, {
      method: "GET",
      headers: {
        'HTTP-Referer': 'https://galygious.github.io/OpenRouterTools',
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch models: ${response.status} ${response.statusText}`);
    }

    const result = await response.json();
    
    if (!result || !Array.isArray(result.data)) {
      throw new Error('Invalid response format from API');
    }

    if (result.data.length === 0) {
      throw new Error('No models returned from API');
    }

    result.data.forEach((model) => {
      if (!model.id) return;

      // Store the full model data
      const modelId = model.id;
      allModelRecords[modelId] = model;

      // Create a friendly display name with pricing info
      const promptPrice = (model.endpoint?.pricing?.prompt || 0) * 1000000;
      const completionPrice = (model.endpoint?.pricing?.completion || 0) * 1000000;
      const avgPrice = (promptPrice + completionPrice) / 2;
      const displayName = `${model.name} ($${avgPrice.toFixed(6)}/1M tok)`;

      // Store the mapping
      modelSlugs[displayName] = modelId;

      // Add to nested structure for organization
      const [provider, modelName] = modelId.split('/');
      if (!nestedModel[provider]) {
        nestedModel[provider] = {};
      }
      nestedModel[provider][modelName] = model;
    });

    if (Object.keys(allModelRecords).length === 0) {
      throw new Error('No valid models found in API response');
    }

    return { nestedModel, allModelRecords };
  } catch (error) {
    console.error("Error fetching models:", error);
    throw error;
  }
}

// Existing helper functions
function getCurrentQuery(fullString) {
  const parts = fullString.split(";");
  return parts[parts.length - 1].trim().toLowerCase();
}

function appendSelectedModel(fullString, selectedModel) {
  const parts = fullString.split(";");
  while (parts.length && parts[parts.length - 1].trim() === "") {
    parts.pop();
  }
  parts[parts.length - 1] = selectedModel;
  return parts.join(";") + ";";
}

function getAllMatches(query, records, excludedModels) {
  const normalizedQuery = query.toLowerCase().trim();
  const queryTokens = extractTokens(normalizedQuery);

  return Object.entries(records)
    .filter(([_, model]) => {
      return !excludedModels.includes(model.name);
    })
    .map(([_, model]) => {
      const normalizedOption = model.name.toLowerCase().trim();
      const optionTokens = extractTokens(normalizedOption);
      const exactMatchScore = (normalizedOption === normalizedQuery) ? -50 : 0;
      const prefixMatchScore = normalizedOption.startsWith(normalizedQuery) ? -20 : 0;
      const substringScore = calculateSubstringScore(queryTokens, normalizedOption);
      const proximityScore = calculateProximityScore(queryTokens, optionTokens);
      const distanceScore = levenshteinDistance(normalizedQuery, normalizedOption);
      
      // Create display name with price
      const promptPrice = (model.endpoint?.pricing?.prompt || 0) * 1000000;
      const displayName = `${model.name} ($${promptPrice.toFixed(2)}/1M tok)`;
      
      return {
        name: displayName,
        score: distanceScore - 10 * substringScore + prefixMatchScore +
                exactMatchScore - 5 * proximityScore
      };
    })
    .sort((a, b) => a.score - b.score)
    .map(item => item.name);
}

function extractTokens(text) {
  return text.split(/[\s\-:/]+|(?<=\d)(?=\D)|(?<=\D)(?=\d)/).filter(Boolean);
}

function calculateSubstringScore(queryTokens, option) {
  return queryTokens.filter(token => option.includes(token)).length;
}

function calculateProximityScore(queryTokens, optionTokens) {
  const queryNumbers = queryTokens.filter(token => /^\d+[a-z]*$/i.test(token));
  const optionNumbers = optionTokens.filter(token => /^\d+[a-z]*$/i.test(token));
  let score = 0;
  queryNumbers.forEach(qNum => {
    const qValue = parseInt(qNum.match(/\d+/)[0]);
    const closestMatch = optionNumbers
      .map(oNum => Math.abs(qValue - parseInt(oNum.match(/\d+/)[0])))
      .sort((a, b) => a - b)[0];
    if (closestMatch !== undefined) {
      score += (1 / (1 + closestMatch));
    }
  });
  return score;
}

function levenshteinDistance(a, b) {
  const matrix = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));
  for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
  for (let j = 0; j <= b.length; j++) matrix[0][j] = j;
  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        matrix[i][j - 1] + 1,
        matrix[i - 1][j - 1] + cost
      );
    }
  }
  return matrix[a.length][b.length];
}

// Event Listeners
const inputField = document.getElementById("model-input");
const suggestionsBox = document.getElementById("suggestions");

inputField.addEventListener("input", () => {
  const fullValue = inputField.value;
  const query = getCurrentQuery(fullValue);

  if (query === "") {
    suggestionsBox.style.display = "none";
    return;
  }

  const selectedModels = fullValue.split(";")
    .map(name => name.trim())
    .filter(name => name !== "");

  const suggestions = getAllMatches(query, modelRecords, selectedModels);
  console.log('Suggestions:', suggestions);  // Debug logging
  displaySuggestions(suggestions);
});

suggestionsBox.addEventListener("click", (event) => {
  if (event.target.tagName === "LI") {
    const newValue = appendSelectedModel(inputField.value, event.target.textContent);
    inputField.value = newValue;
    suggestionsBox.style.display = "none";
  }
});

document.getElementById('fetch-button').addEventListener('click', () => {
  const fullInputValue = document.getElementById('model-input').value;
  let modelNames = fullInputValue
    .split(";")
    .map(name => name.trim())
    .filter(name => name !== "");

  fetchStatsForAllModels(modelNames);
});

document.getElementById('fetch-all-button').addEventListener('click', async () => {
  try {
    // If models aren't loaded yet, load them
    if (Object.keys(modelRecords).length === 0) {
      const { nestedModel, allModelRecords } = await fetchModels();
      modelData = nestedModel;
      modelRecords = allModelRecords;
    }

    // Get all model display names (which include pricing info)
    const allModelNames = Object.keys(modelSlugs);
    
    if (allModelNames.length > 0) {
      fetchStatsForAllModels(allModelNames);
    } else {
      document.getElementById('error-message').textContent = 'Error loading models. Please try again.';
    }
  } catch (error) {
    console.error('Error loading models:', error);
    document.getElementById('error-message').textContent = 'Error loading models. Please try again.';
  }
});

function displaySuggestions(suggestions) {
  if (!suggestions.length) {
    suggestionsBox.style.display = "none";
    return;
  }
  suggestionsBox.innerHTML = suggestions.map(s => `<li>${s}</li>`).join("");
  suggestionsBox.style.display = "block";
}

async function fetchStatsForAllModels(modelNames) {
  const errorMessage = document.getElementById('error-message');
  const tableBody = document.querySelector('#stats-table tbody');
  const loadingIndicator = document.getElementById('loading');

  tableBody.innerHTML = '';
  errorMessage.textContent = '';

  if (modelNames.length === 0) {
    errorMessage.textContent = 'Please enter at least one model name.';
    return;
  }

  loadingIndicator.style.display = 'block';

  try {
    const fetchPromises = modelNames.map(name => fetchStatsForSingleModel(name));
    const results = await Promise.all(fetchPromises);
    const rows = results.flat().filter(Boolean);

    if (rows.length === 0) {
      errorMessage.textContent = 'No valid providers found for given model(s).';
      return;
    }

    rows.forEach(row => tableBody.appendChild(row));
  } catch (error) {
    console.error('Error fetching data:', error);
    errorMessage.textContent = 'An error occurred while fetching data.';
  } finally {
    loadingIndicator.style.display = 'none';
  }
}

async function fetchStatsForSingleModel(modelName) {
  const tableRows = [];
  const modelId = modelSlugs[modelName];
  if (!modelId) return tableRows;

  try {
    const model = modelRecords[modelId];
    if (!model) return tableRows;

    const row = document.createElement('tr');
    const promptPrice = (model.endpoint?.pricing?.prompt || 0) * 1000000;
    const completionPrice = (model.endpoint?.pricing?.completion || 0) * 1000000;
    const avgLatency = model.endpoint?.latency?.avg_ms ?
      (model.endpoint.latency.avg_ms / 1000).toFixed(3) : 'N/A';
    
    row.innerHTML = `
      <td>${model.name}</td>
      <td>${model.endpoint?.provider_display_name || 'N/A'}</td>
      <td>${model.context_length || 'N/A'}</td>
      <td>${model.endpoint?.max_completion_tokens || model.context_length || 'N/A'}</td>
      <td>$${promptPrice.toFixed(6)}</td>
      <td>$${completionPrice.toFixed(6)}</td>
      <td>${avgLatency}</td>
      <td>${model.endpoint?.throughput || 'N/A'}</td>
    `;
    tableRows.push(row);
  } catch (error) {
    console.error('Error processing model data for', modelName, error);
  }
  return tableRows;
}
