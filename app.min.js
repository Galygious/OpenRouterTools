// OpenRouter Model Selection and Chat Interface

document.addEventListener('DOMContentLoaded', () => {
  // Initialize Select2
  $('.select2').select2({
    width: '100%',
    theme: 'classic',
    placeholder: function() {
      return $(this).data('placeholder') || $(this).find('option:first').text();
    }
  });

  // Constants
  const OPENROUTER_API = {
    BASE_URL: 'https://openrouter.ai/api',
    MODELS_ENDPOINT: '/v1/models'
  };

  // DOM Element References
  const apiKey = document.getElementById('api-key');
  const saveKeyBtn = document.getElementById('save-key');
  const statsTab = document.getElementById('stats-tab');
  const chatTab = document.getElementById('chat-tab');
  const statsView = document.getElementById('stats-view');
  const chatView = document.getElementById('chat-view');
  
  // Stats View Elements
  const modelInput = document.getElementById('model-input');
  const fetchButton = document.getElementById('fetch-button');
  const fetchAllButton = document.getElementById('fetch-all-button');
  const suggestionsContainer = document.getElementById('suggestions');
  const errorMessage = document.getElementById('error-message');
  const loadingIndicator = document.getElementById('loading');
  const statsTable = document.getElementById('stats-table').querySelector('tbody');

  // Model Selection Dropdowns
  const creatorDropdown = $('#creator-dropdown');
  const modelDropdown = $('#model-dropdown');
  const versionDropdown = $('#version-dropdown');
  const providerDropdown = $('#provider-dropdown');

  // Model Details Elements
  const pricingPrompt = document.getElementById('prompt-price');
  const pricingCompletion = document.getElementById('completion-price');
  const modelDescription = document.getElementById('model-description');

  // State Management
  let modelData = [];
  let apiKeyValue = localStorage.getItem('openrouter_api_key');

  // API Key Management
  if (apiKeyValue) {
    apiKey.value = apiKeyValue;
  }

  saveKeyBtn.addEventListener('click', () => {
    const key = apiKey.value.trim();
    if (!key) {
      showError('Please enter an API key');
      return;
    }
    localStorage.setItem('openrouter_api_key', key);
    apiKeyValue = key;
    fetchModelData();
  });

  // API Utilities
  async function fetchWithAuth(url, options = {}) {
    if (!apiKeyValue) {
      throw new Error('API key is required');
    }

    const headers = {
      'Authorization': `Bearer ${apiKeyValue}`,
      'HTTP-Referer': window.location.origin,
      ...options.headers
    };

    const response = await fetch(url, { ...options, headers });
    
    if (!response.ok) {
      if (response.status === 401) {
        localStorage.removeItem('openrouter_api_key');
        throw new Error('Invalid API key');
      }
      throw new Error(`API request failed: ${response.statusText}`);
    }

    return response.json();
  }

  function showError(message) {
    errorMessage.textContent = message;
    errorMessage.classList.remove('hidden');
    setTimeout(() => {
      errorMessage.classList.add('hidden');
    }, 5000);
  }

  function showLoading(show = true) {
    loadingIndicator.classList.toggle('hidden', !show);
  }

  // Model Data Management
  async function fetchModelData() {
    showLoading(true);
    errorMessage.classList.add('hidden');
    statsTable.innerHTML = '';

    try {
      const response = await fetchWithAuth(`${OPENROUTER_API.BASE_URL}${OPENROUTER_API.MODELS_ENDPOINT}`);
      console.log('API Response:', response);
      modelData = response.data || [];
      
      // Process model data to ensure all required fields
      modelData = modelData.map(model => ({
        ...model,
        provider: model.provider || model.endpoint?.provider_name,
        name: model.name || model.short_name,
        version: model.version || 'default'
      }));
      
      console.log('Processed Model Data:', modelData);
      populateCreatorDropdown();
      setupModelSearch();
    } catch (error) {
      console.error('Error fetching model data:', error);
      console.log('API response error:', error); // Added log
      showError(error.message);
    } finally {
      showLoading(false);
    }
  }

  function setupModelSearch() {
    modelInput.addEventListener('input', () => {
      const searchTerm = modelInput.value.toLowerCase();
      if (searchTerm.length < 2) {
        suggestionsContainer.classList.add('hidden');
        return;
      }

      const matches = modelData.filter(model => 
        model.id?.toLowerCase().includes(searchTerm) ||
        model.name?.toLowerCase().includes(searchTerm)
      );

      suggestionsContainer.innerHTML = '';
      matches.slice(0, 5).forEach(model => {
        const li = document.createElement('li');
        li.className = 'px-4 py-2 hover:bg-gray-100 cursor-pointer text-base';
        li.textContent = `${model.name} (${model.id})`;
        li.addEventListener('click', () => {
          modelInput.value = model.id;
          suggestionsContainer.classList.add('hidden');
          fetchModelStats(model.id);
        });
        suggestionsContainer.appendChild(li);
      });
      suggestionsContainer.classList.remove('hidden');
    });
  }

  async function fetchModelStats(modelId) {
    showLoading(true);
    errorMessage.classList.add('hidden');
    statsTable.innerHTML = '';

    try {
      const model = modelData.find(m => m.id === modelId);
      if (!model) {
        throw new Error('Model not found');
      }

      const row = document.createElement('tr');
      row.className = 'hover:bg-gray-50 text-base';
      row.innerHTML = `
        <td class="px-6 py-4 whitespace-nowrap">${model.id || '-'}</td>
        <td class="px-6 py-4 whitespace-nowrap">${model.provider || '-'}</td>
        <td class="px-6 py-4 whitespace-nowrap">${model.context_length || '-'}</td>
        <td class="px-6 py-4 whitespace-nowrap">${model.max_completion_tokens || '-'}</td>
        <td class="px-6 py-4 whitespace-nowrap">${model.pricing?.prompt || '-'}</td>
        <td class="px-6 py-4 whitespace-nowrap">${model.pricing?.completion || '-'}</td>
        <td class="px-6 py-4 whitespace-nowrap">${model.latency?.avg?.toFixed(2) || '-'}</td>
        <td class="px-6 py-4 whitespace-nowrap">${model.throughput?.toFixed(2) || '-'}</td>
      `;
      statsTable.appendChild(row);
    } catch (error) {
      showError(error.message);
    } finally {
      showLoading(false);
    }
  }

  async function fetchAllStats() {
    showLoading(true);
    errorMessage.classList.add('hidden');
    statsTable.innerHTML = '';

    try {
      modelData.forEach(model => {
        const row = document.createElement('tr');
        row.className = 'hover:bg-gray-50 text-base';
        row.innerHTML = `
          <td class="px-6 py-4 whitespace-nowrap">${model.id || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${model.provider || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${model.context_length || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${model.max_completion_tokens || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${model.pricing?.prompt || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${model.pricing?.completion || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${model.latency?.avg?.toFixed(2) || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${model.throughput?.toFixed(2) || '-'}</td>
        `;
        statsTable.appendChild(row);
      });
    } catch (error) {
      showError('Failed to fetch all stats');
    } finally {
      showLoading(false);
    }
  }

  // Event Listeners for Stats View
  fetchButton.addEventListener('click', () => {
    const modelId = modelInput.value.trim();
    if (modelId) {
      fetchModelStats(modelId);
    } else {
      showError('Please enter a model name');
    }
  });

  fetchAllButton.addEventListener('click', fetchAllStats);

  function populateCreatorDropdown() {
    console.log('Populating creators from:', modelData);
    const creators = [...new Set(modelData.map(model => {
      console.log('Processing model:', model);
      // Extract creator from model name (e.g., "DeepSeek: DeepSeek R1" -> "DeepSeek")
      const creatorMatch = model.name?.match(/^([^:]+):/);
      return creatorMatch ? creatorMatch[1].trim() : model.provider;
    }))].filter(Boolean);
    console.log('Extracted creators:', creators);
    creators.sort();

    creatorDropdown.empty();
    creators.forEach(creator => {
      console.log('Adding creator option:', creator);
      creatorDropdown.append(new Option(creator, creator));
    });

    // Initialize select2 with placeholder
    creatorDropdown.select2({
      placeholder: "Select a creator...",
      allowClear: true
    });

    creatorDropdown.off('change').on('change', handleCreatorSelection);
    console.log('Creator dropdown options:', creatorDropdown.children().length, creatorDropdown.children().map(function() { return this.text; }).get());
  }

  function handleCreatorSelection() {
    const selectedCreator = creatorDropdown.val();
    console.log('Selected Creator:', selectedCreator);
    
    // Reset and disable subsequent dropdowns
    modelDropdown.empty();
    versionDropdown.empty();
    providerDropdown.empty();

    // Initialize select2 for dependent dropdowns
    modelDropdown.select2({
      placeholder: "Select a model...",
      allowClear: true
    }).prop('disabled', true);

    versionDropdown.select2({
      placeholder: "Select a version...",
      allowClear: true
    }).prop('disabled', true);

    providerDropdown.select2({
      placeholder: "Select a provider with pricing...",
      allowClear: true
    }).prop('disabled', true);

    if (!selectedCreator) return;

    const creatorModels = modelData.filter(model => {
      const creatorMatch = model.name?.match(/^([^:]+):/);
      const creator = creatorMatch ? creatorMatch[1].trim() : model.provider;
      return creator === selectedCreator;
    });
    console.log('Creator Models:', creatorModels);
    
    // Extract base model names (without versions)
    const baseModels = new Map();
    creatorModels.forEach(model => {
      const nameWithoutCreator = model.name.replace(new RegExp(`^${selectedCreator}:\\s*`), '');
      const baseModelName = nameWithoutCreator.split(/\s+(?:v\d|[(]|$)/)[0].trim();
      if (!baseModels.has(baseModelName)) {
        baseModels.set(baseModelName, []);
      }
      baseModels.get(baseModelName).push(model);
    });

    const sortedBaseModels = Array.from(baseModels.keys()).sort();
    sortedBaseModels.forEach(modelName => {
      modelDropdown.append(new Option(modelName, modelName));
    });

    modelDropdown.prop('disabled', false);
  }

  function handleModelSelection() {
    const selectedCreator = creatorDropdown.val();
    const selectedModel = modelDropdown.val();
    console.log('Selected Model:', selectedModel);
    
    // Reset and disable subsequent dropdowns
    versionDropdown.empty();
    providerDropdown.empty();

    // Initialize select2 for dependent dropdowns
    versionDropdown.select2({
      placeholder: "Select a version...",
      allowClear: true
    }).prop('disabled', true);

    providerDropdown.select2({
      placeholder: "Select a provider with pricing...",
      allowClear: true
    }).prop('disabled', true);

    if (!selectedModel) return;

    // Find all models that match the selected base model name
    const modelVersions = modelData.filter(model => {
      const nameWithoutCreator = model.name.replace(new RegExp(`^${selectedCreator}:\\s*`), '');
      const baseModelName = nameWithoutCreator.split(/\s+(?:v\d|[(]|$)/)[0].trim();
      return baseModelName === selectedModel;
    });
    console.log('Model Versions:', modelVersions);

    // Extract version information
    const versions = new Set();
    modelVersions.forEach(model => {
      const nameWithoutCreator = model.name.replace(new RegExp(`^${selectedCreator}:\\s*`), '');
      const versionMatch = nameWithoutCreator.match(/\s+v(\d+(\.\d+)*)|[(](.*?)[)]/);
      const version = versionMatch ? versionMatch[0].trim() : 'default';
      versions.add(version);
    });

    // Sort versions naturally
    const sortedVersions = Array.from(versions).sort((a, b) => {
      if (a === 'default') return -1;
      if (b === 'default') return 1;
      return a.localeCompare(b, undefined, {numeric: true});
    });

    sortedVersions.forEach(version => {
      versionDropdown.append(new Option(version, version));
    });

    versionDropdown.prop('disabled', false);
  }

  async function handleVersionSelection() {
    const selectedCreator = creatorDropdown.val();
    const selectedModel = modelDropdown.val();
    const selectedVersion = versionDropdown.val();
    console.log('Selected Version:', selectedVersion);
    
    // Reset and disable provider dropdown
    providerDropdown.empty();
    providerDropdown.select2({
      placeholder: "Select a provider with pricing...",
      allowClear: true
    }).prop('disabled', true);

    if (!selectedVersion) return;

    // Find the matching model
    const matchingModel = modelData.find(model => {
      const nameWithoutCreator = model.name.replace(new RegExp(`^${selectedCreator}:\\s*`), '');
      const baseModelName = nameWithoutCreator.split(/\s+(?:v\d|[(]|$)/)[0].trim();
      const versionMatch = nameWithoutCreator.match(/\s+v(\d+(\.\d+)*)|[(](.*?)[)]/);
      const version = versionMatch ? versionMatch[0].trim() : 'default';
      const creatorMatch = model.name?.match(/^([^:]+):/);
      const modelCreator = creatorMatch ? creatorMatch[1].trim() : model.provider;
      return modelCreator === selectedCreator &&
             baseModelName === selectedModel &&
             version === selectedVersion;
    });

    if (!matchingModel) {
      console.log('No matching model found');
      return;
    }

    console.log('Fetching providers for model:', matchingModel.id);
    showLoading(true);

    try {
      // Encode the permaslug for the URL
      const permaslug = encodeURIComponent(matchingModel.id);
      const response = await fetchWithAuth(
        `${OPENROUTER_API.BASE_URL}/frontend/stats/endpoint?permaslug=${permaslug}&variant=standard`
      );
      console.log('Provider Response:', response);

      if (response.data && response.data.length > 0) {
        // Sort providers by price
        response.data.sort((a, b) =>
          (parseFloat(a.pricing?.prompt) || 0) - (parseFloat(b.pricing?.prompt) || 0)
        );
        
        response.data.forEach(config => {
          // Convert prices to per million tokens
          const promptPrice = (parseFloat(config.pricing?.prompt || 0) * 1000000).toFixed(2);
          const completionPrice = (parseFloat(config.pricing?.completion || 0) * 1000000).toFixed(2);
          const optionText = `${config.provider_display_name} ($${promptPrice}/1M prompt tokens, $${completionPrice}/1M completion tokens)`;
          providerDropdown.append(new Option(optionText, config.id));
        });

        providerDropdown.prop('disabled', false);
      } else {
        console.log('No providers found for model');
      }
    } catch (error) {
      console.error('Error fetching providers:', error);
      showError('Failed to fetch providers');
    } finally {
      showLoading(false);
    }
  }

  function handleProviderSelection() {
    const selectedConfig = providerDropdown.val();
    if (!selectedConfig) return;

    const selectedModelEntry = modelData.find(model => model.id === selectedConfig);
    if (selectedModelEntry) {
      // Convert prices to per million tokens
      const promptPrice = (parseFloat(selectedModelEntry.pricing?.prompt || 0) * 1000000).toFixed(2);
      const completionPrice = (parseFloat(selectedModelEntry.pricing?.completion || 0) * 1000000).toFixed(2);
      pricingPrompt.textContent = `Prompt Price: $${promptPrice} per 1M tokens`;
      pricingCompletion.textContent = `Completion Price: $${completionPrice} per 1M tokens`;
      modelDescription.textContent = selectedModelEntry.description || 'No description available.';
    }
  }

  // Initialize Select2 event handlers
  modelDropdown.off('change').on('change', handleModelSelection);
  versionDropdown.off('change').on('change', handleVersionSelection);
  providerDropdown.off('change').on('change', handleProviderSelection);

  // Tab Navigation
  statsTab.addEventListener('click', () => {
    statsTab.classList.add('active', 'bg-blue-500', 'text-white');
    chatTab.classList.remove('active', 'bg-blue-500', 'text-white');
    statsView.classList.remove('hidden');
    chatView.classList.add('hidden');
    statsTab.setAttribute('aria-pressed', 'true');
    chatTab.setAttribute('aria-pressed', 'false');
  });

  chatTab.addEventListener('click', () => {
    chatTab.classList.add('active', 'bg-blue-500', 'text-white');
    statsTab.classList.remove('active', 'bg-blue-500', 'text-white');
    chatView.classList.remove('hidden');
    statsView.classList.add('hidden');
    chatTab.setAttribute('aria-pressed', 'true');
    statsTab.setAttribute('aria-pressed', 'false');
  });

  // Initialize if API key exists
  if (apiKeyValue) {
    fetchModelData();
  }
});
