// OpenRouter Model Selection and Chat Interface

document.addEventListener('DOMContentLoaded', () => {
  // Initialize Select2
  $('.select2').select2({
    width: '100%',
    theme: 'classic',
    placeholder: function() {
      return $(this).data('placeholder') || $(this).find('option:first').text();
    }
  });

  // Constants
  const OPENROUTER_API = {
    BASE_URL: 'https://openrouter.ai/api',
    MODELS_ENDPOINT: '/frontend/models',
    STATS_ENDPOINT: '/frontend/stats/endpoint'
  };

  // DOM Element References
  const apiKey = document.getElementById('api-key');
  const saveKeyBtn = document.getElementById('save-key');
  const statsTab = document.getElementById('stats-tab');
  const chatTab = document.getElementById('chat-tab');
  const statsView = document.getElementById('stats-view');
  const chatView = document.getElementById('chat-view');
  
  // Stats View Elements
  const modelInput = document.getElementById('model-input');
  const fetchButton = document.getElementById('fetch-button');
  const fetchAllButton = document.getElementById('fetch-all-button');
  const suggestionsContainer = document.getElementById('suggestions');
  const errorMessage = document.getElementById('error-message');
  const loadingIndicator = document.getElementById('loading');
  const statsTable = document.getElementById('stats-table').querySelector('tbody');

  // Model Selection Dropdowns
  const creatorDropdown = $('#creator-dropdown');
  const modelDropdown = $('#model-dropdown');
  const versionDropdown = $('#version-dropdown');
  const providerDropdown = $('#provider-dropdown');

  // Model Details Elements
  const pricingPrompt = document.getElementById('prompt-price');
  const pricingCompletion = document.getElementById('completion-price');
  const modelDescription = document.getElementById('model-description');

  // State Management
  let modelData = [];
  let apiKeyValue = localStorage.getItem('openrouter_api_key');

  // API Key Management
  if (apiKeyValue) {
    apiKey.value = apiKeyValue;
  }

  saveKeyBtn.addEventListener('click', () => {
    const key = apiKey.value.trim();
    if (!key) {
      showError('Please enter an API key');
      return;
    }
    localStorage.setItem('openrouter_api_key', key);
    apiKeyValue = key;
    // API key is optional for model data, but we'll store it for chat functionality
    fetchModelData();
  });

  // API Utilities
  async function fetchWithAuth(url, options = {}) {
    const response = await fetch(url, {
      ...options,
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        ...options.headers
      }
    });
    
    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`);
    }

    return await response.json();
  }

  function showError(message) {
    errorMessage.textContent = message;
    errorMessage.classList.remove('hidden');
    setTimeout(() => {
      errorMessage.classList.add('hidden');
    }, 5000);
  }

  function showLoading(show = true) {
    loadingIndicator.classList.toggle('hidden', !show);
  }

  // Find the fastest provider by average ranking of latency and throughput
  function findFastestProvider(providers) {
    if (!providers || providers.length === 0) return null;
    
    // Filter out providers with no stats or invalid status
    const validProviders = providers.filter(provider => 
      provider.stats && 
      provider.stats.p50_latency && 
      provider.stats.p50_throughput &&
      provider.status === 0 // Only active providers
    );
    
    if (validProviders.length === 0) return providers[0]; // Fallback to first provider
    
    // Calculate average ranking for each provider
    const providersWithRanking = validProviders.map(provider => {
      const latency = provider.stats.p50_latency;
      const throughput = provider.stats.p50_throughput;
      
      // Lower latency is better, higher throughput is better
      const latencyRank = validProviders.filter(p => p.stats.p50_latency < latency).length + 1;
      const throughputRank = validProviders.filter(p => p.stats.p50_throughput > throughput).length + 1;
      
      const averageRank = (latencyRank + throughputRank) / 2;
      
      return {
        ...provider,
        averageRank
      };
    });
    
    // Sort by average ranking (lower is better)
    providersWithRanking.sort((a, b) => a.averageRank - b.averageRank);
    
    return providersWithRanking[0];
  }

  // Model Data Management
  async function fetchModelData() {
    showLoading(true);
    errorMessage.classList.add('hidden');
    statsTable.innerHTML = '';

    try {
      const response = await fetchWithAuth(`${OPENROUTER_API.BASE_URL}${OPENROUTER_API.MODELS_ENDPOINT}`);
      
      // Handle both data formats (array or object with data property)
      modelData = Array.isArray(response) ? response : (response.data || []);
      
      // Process model data to ensure all required fields
      modelData = modelData.map(model => {
        const processedModel = {
          ...model,
          provider: model.provider || model.endpoint?.provider_name,
          name: model.name || model.short_name || model.slug,
          version: model.version || 'default',
          id: model.slug || model.id,
          context_length: model.context_length,
          max_completion_tokens: model.endpoint?.max_completion_tokens,
          pricing: model.endpoint?.pricing
        };
        return processedModel;
      });
      
      populateCreatorDropdown();
      setupModelSearch();
    } catch (error) {
      console.error('Error fetching model data:', error);
      showError(error.message);
    } finally {
      showLoading(false);
    }
  }

  function setupModelSearch() {
    modelInput.addEventListener('input', () => {
      const searchTerm = modelInput.value.toLowerCase();
      if (searchTerm.length < 2) {
        suggestionsContainer.classList.add('hidden');
        return;
      }

      const matches = modelData.filter(model => 
        model.id?.toLowerCase().includes(searchTerm) ||
        model.name?.toLowerCase().includes(searchTerm)
      );

      suggestionsContainer.innerHTML = '';
      matches.slice(0, 5).forEach(model => {
        const li = document.createElement('li');
        li.className = 'px-4 py-2 hover:bg-gray-100 cursor-pointer text-base';
        li.textContent = `${model.name} (${model.id})`;
        li.addEventListener('click', () => {
          modelInput.value = model.id;
          suggestionsContainer.classList.add('hidden');
          fetchModelStats(model.id);
        });
        suggestionsContainer.appendChild(li);
      });
      suggestionsContainer.classList.remove('hidden');
    });
  }

  async function fetchModelStats(modelId) {
    showLoading(true);
    errorMessage.classList.add('hidden');
    statsTable.innerHTML = '';

    try {
      const model = modelData.find(m => m.id === modelId);
      if (!model) {
        throw new Error('Model not found');
      }

      // Fetch stats for this model using the new endpoint
      const permaslug = encodeURIComponent(modelId);
      const statsResponse = await fetchWithAuth(
        `${OPENROUTER_API.BASE_URL}${OPENROUTER_API.STATS_ENDPOINT}?permaslug=${permaslug}&variant=standard`
      );

      if (statsResponse.data && statsResponse.data.length > 0) {
        // Find the fastest provider by average ranking
        const fastestProvider = findFastestProvider(statsResponse.data);
        
        const row = document.createElement('tr');
        row.className = 'hover:bg-gray-50 text-base';
        row.innerHTML = `
          <td class="px-6 py-4 whitespace-nowrap">${model.id || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.provider_display_name || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.context_length || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.max_completion_tokens || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.pricing?.prompt || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.pricing?.completion || '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.stats?.p50_latency ? (fastestProvider.stats.p50_latency / 1000).toFixed(2) : '-'}</td>
          <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.stats?.p50_throughput?.toFixed(2) || '-'}</td>
        `;
        statsTable.appendChild(row);
      } else {
        throw new Error('No stats available for this model');
      }
    } catch (error) {
      showError(error.message);
    } finally {
      showLoading(false);
    }
  }

  async function fetchAllStats() {
    showLoading(true);
    errorMessage.classList.add('hidden');
    statsTable.innerHTML = '';

    try {
      // Process a limited number of models to avoid overwhelming the API
      const modelsToProcess = modelData.slice(0, 10); // Limit to first 10 models
      
      for (const model of modelsToProcess) {
        try {
          const permaslug = encodeURIComponent(model.id);
          const statsResponse = await fetchWithAuth(
            `${OPENROUTER_API.BASE_URL}${OPENROUTER_API.STATS_ENDPOINT}?permaslug=${permaslug}&variant=standard`
          );

          if (statsResponse.data && statsResponse.data.length > 0) {
            const fastestProvider = findFastestProvider(statsResponse.data);
            
            const row = document.createElement('tr');
            row.className = 'hover:bg-gray-50 text-base';
            row.innerHTML = `
              <td class="px-6 py-4 whitespace-nowrap">${model.id || '-'}</td>
              <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.provider_display_name || '-'}</td>
              <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.context_length || '-'}</td>
              <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.max_completion_tokens || '-'}</td>
              <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.pricing?.prompt || '-'}</td>
              <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.pricing?.completion || '-'}</td>
              <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.stats?.p50_latency ? (fastestProvider.stats.p50_latency / 1000).toFixed(2) : '-'}</td>
              <td class="px-6 py-4 whitespace-nowrap">${fastestProvider.stats?.p50_throughput?.toFixed(2) || '-'}</td>
            `;
            statsTable.appendChild(row);
          }
        } catch (error) {
          console.warn(`Failed to fetch stats for model ${model.id}:`, error);
          // Continue with next model
        }
      }
    } catch (error) {
      showError('Failed to fetch all stats');
    } finally {
      showLoading(false);
    }
  }

  // Event Listeners for Stats View
  fetchButton.addEventListener('click', () => {
    const modelId = modelInput.value.trim();
    if (modelId) {
      fetchModelStats(modelId);
    } else {
      showError('Please enter a model name');
    }
  });

  fetchAllButton.addEventListener('click', fetchAllStats);

  function populateCreatorDropdown() {
    console.log('Populating creators from:', modelData);
    const creators = [...new Set(modelData.map(model => {
      console.log('Processing model:', model);
      // Extract creator from model name (e.g., "DeepSeek: DeepSeek R1" -> "DeepSeek")
      const creatorMatch = model.name?.match(/^([^:]+):/);
      return creatorMatch ? creatorMatch[1].trim() : model.provider;
    }))].filter(Boolean);
    console.log('Extracted creators:', creators);
    creators.sort();

    creatorDropdown.empty();
    creators.forEach(creator => {
      console.log('Adding creator option:', creator);
      creatorDropdown.append(new Option(creator, creator));
    });

    // Initialize select2 with placeholder
    creatorDropdown.select2('destroy').select2({
      placeholder: "Select a creator...",
      allowClear: true
    }).on('select2:select', function(e) {
      console.log('Creator dropdown select event fired');
      console.log('Selected data:', e.params.data);
      handleCreatorSelection();
    });
    console.log('Creator dropdown options:', creatorDropdown.children().length, creatorDropdown.children().map(function() { return this.text; }).get());
    console.log('Event handler attached to creator dropdown');
  }

  function handleCreatorSelection() {
    const selectedCreator = creatorDropdown.val();
    console.log('Selected Creator:', selectedCreator);
    
    // Reset and disable subsequent dropdowns
    modelDropdown.empty();
    versionDropdown.empty();
    providerDropdown.empty();

    // Initialize select2 for dependent dropdowns
    modelDropdown.select2({
      placeholder: "Select a model...",
      allowClear: true
    }).prop('disabled', true);

    versionDropdown.select2({
      placeholder: "Select a version...",
      allowClear: true
    }).prop('disabled', true);

    providerDropdown.select2({
      placeholder: "Select a provider with pricing...",
      allowClear: true
    }).prop('disabled', true);

    if (!selectedCreator) return;

    console.log('Model data in handleCreatorSelection:', modelData);
    const creatorModels = modelData.filter(model => {
      const creatorMatch = model.name?.match(/^([^:]+):/);
      const creator = creatorMatch ? creatorMatch[1].trim() : model.provider;
      console.log('Checking model:', model.name, 'Creator:', creator, 'Selected:', selectedCreator);
      return creator === selectedCreator;
    });
    console.log('Creator Models:', creatorModels);
    console.log('Creator Models length:', creatorModels.length);
    
    // Extract base model names (without versions)
    const baseModels = new Map();
    creatorModels.forEach(model => {
      let baseModelName;
      if (model.name.includes(':')) {
        const nameWithoutCreator = model.name.replace(new RegExp(`^${selectedCreator}:\\s*`), '');
        baseModelName = nameWithoutCreator.split(/\s+(?:v\d|[(]|$)/)[0].trim();
      } else {
        baseModelName = model.name.split(/\s+(?:v\d|[(]|$)/)[0].trim();
      }
      console.log('Extracted base model name:', baseModelName, 'from:', model.name);
      if (!baseModels.has(baseModelName)) {
        baseModels.set(baseModelName, []);
      }
      baseModels.get(baseModelName).push(model);
    });

    const sortedBaseModels = Array.from(baseModels.keys()).sort();
    console.log('Sorted base models:', sortedBaseModels);
    sortedBaseModels.forEach(modelName => {
      modelDropdown.append(new Option(modelName, modelName));
    });

    modelDropdown.prop('disabled', false);
  }

  function handleModelSelection() {
    const selectedCreator = creatorDropdown.val();
    const selectedModel = modelDropdown.val();
    console.log('Selected Model:', selectedModel);
    
    // Reset and disable subsequent dropdowns
    versionDropdown.empty();
    providerDropdown.empty();

    // Initialize select2 for dependent dropdowns
    versionDropdown.select2({
      placeholder: "Select a version...",
      allowClear: true
    }).prop('disabled', true);

    providerDropdown.select2({
      placeholder: "Select a provider with pricing...",
      allowClear: true
    }).prop('disabled', true);

    if (!selectedModel) return;

    // Find all models that match the selected base model name
    const modelVersions = modelData.filter(model => {
      const nameWithoutCreator = model.name.replace(new RegExp(`^${selectedCreator}:\\s*`), '');
      const baseModelName = nameWithoutCreator.split(/\s+(?:v\d|[(]|$)/)[0].trim();
      return baseModelName === selectedModel;
    });
    console.log('Model Versions:', modelVersions);

    // Extract version information
    const versions = new Set();
    modelVersions.forEach(model => {
      const nameWithoutCreator = model.name.replace(new RegExp(`^${selectedCreator}:\\s*`), '');
      const versionMatch = nameWithoutCreator.match(/\s+v(\d+(\.\d+)*)|[(](.*?)[)]/);
      const version = versionMatch ? versionMatch[0].trim() : 'default';
      versions.add(version);
    });

    // Sort versions naturally
    const sortedVersions = Array.from(versions).sort((a, b) => {
      if (a === 'default') return -1;
      if (b === 'default') return 1;
      return a.localeCompare(b, undefined, {numeric: true});
    });

    sortedVersions.forEach(version => {
      versionDropdown.append(new Option(version, version));
    });

    versionDropdown.prop('disabled', false);
  }

  async function handleVersionSelection() {
    const selectedCreator = creatorDropdown.val();
    const selectedModel = modelDropdown.val();
    const selectedVersion = versionDropdown.val();
    console.log('Selected Version:', selectedVersion);
    
    // Reset and disable provider dropdown
    providerDropdown.empty();
    providerDropdown.select2({
      placeholder: "Select a provider with pricing...",
      allowClear: true
    }).prop('disabled', true);

    if (!selectedVersion) return;

    // Find the matching model
    const matchingModel = modelData.find(model => {
      const nameWithoutCreator = model.name.replace(new RegExp(`^${selectedCreator}:\\s*`), '');
      const baseModelName = nameWithoutCreator.split(/\s+(?:v\d|[(]|$)/)[0].trim();
      const versionMatch = nameWithoutCreator.match(/\s+v(\d+(\.\d+)*)|[(](.*?)[)]/);
      const version = versionMatch ? versionMatch[0].trim() : 'default';
      const creatorMatch = model.name?.match(/^([^:]+):/);
      const modelCreator = creatorMatch ? creatorMatch[1].trim() : model.provider;
      return modelCreator === selectedCreator &&
             baseModelName === selectedModel &&
             version === selectedVersion;
    });

    if (!matchingModel) {
      console.log('No matching model found');
      return;
    }

    console.log('Fetching providers for model:', matchingModel.id);
    showLoading(true);

    try {
      // Encode the permaslug for the URL
      const permaslug = encodeURIComponent(matchingModel.id);
      const response = await fetchWithAuth(
        `${OPENROUTER_API.BASE_URL}${OPENROUTER_API.STATS_ENDPOINT}?permaslug=${permaslug}&variant=standard`
      );
      console.log('Provider Response:', response);

      if (response.data && response.data.length > 0) {
        // Find the fastest provider and sort others by price
        const fastestProvider = findFastestProvider(response.data);
        const otherProviders = response.data.filter(p => p.id !== fastestProvider.id);
        
        // Sort other providers by price
        otherProviders.sort((a, b) =>
          (parseFloat(a.pricing?.prompt) || 0) - (parseFloat(b.pricing?.prompt) || 0)
        );
        
        // Add fastest provider first
        const promptPrice = (parseFloat(fastestProvider.pricing?.prompt || 0) * 1000000).toFixed(2);
        const completionPrice = (parseFloat(fastestProvider.pricing?.completion || 0) * 1000000).toFixed(2);
        const fastestOptionText = `🚀 ${fastestProvider.provider_display_name} (FASTEST - $${promptPrice}/1M prompt, $${completionPrice}/1M completion)`;
        providerDropdown.append(new Option(fastestOptionText, fastestProvider.id));
        
        // Add other providers
        otherProviders.forEach(config => {
          const promptPrice = (parseFloat(config.pricing?.prompt || 0) * 1000000).toFixed(2);
          const completionPrice = (parseFloat(config.pricing?.completion || 0) * 1000000).toFixed(2);
          const optionText = `${config.provider_display_name} ($${promptPrice}/1M prompt tokens, $${completionPrice}/1M completion tokens)`;
          providerDropdown.append(new Option(optionText, config.id));
        });

        providerDropdown.prop('disabled', false);
      } else {
        console.log('No providers found for model');
      }
    } catch (error) {
      console.error('Error fetching providers:', error);
      showError('Failed to fetch providers');
    } finally {
      showLoading(false);
    }
  }

  function handleProviderSelection() {
    const selectedConfig = providerDropdown.val();
    if (!selectedConfig) return;

    const selectedModelEntry = modelData.find(model => model.id === selectedConfig);
    if (selectedModelEntry) {
      // Convert prices to per million tokens
      const promptPrice = (parseFloat(selectedModelEntry.pricing?.prompt || 0) * 1000000).toFixed(2);
      const completionPrice = (parseFloat(selectedModelEntry.pricing?.completion || 0) * 1000000).toFixed(2);
      pricingPrompt.textContent = `Prompt Price: $${promptPrice} per 1M tokens`;
      pricingCompletion.textContent = `Completion Price: $${completionPrice} per 1M tokens`;
      modelDescription.textContent = selectedModelEntry.description || 'No description available.';
    }
  }

  // Initialize Select2 event handlers
  modelDropdown.off('change').on('change', handleModelSelection);
  versionDropdown.off('change').on('change', handleVersionSelection);
  providerDropdown.off('change').on('change', handleProviderSelection);

  // Tab Navigation
  statsTab.addEventListener('click', () => {
    statsTab.classList.add('active', 'bg-blue-500', 'text-white');
    chatTab.classList.remove('active', 'bg-blue-500', 'text-white');
    statsView.classList.remove('hidden');
    chatView.classList.add('hidden');
    statsTab.setAttribute('aria-pressed', 'true');
    chatTab.setAttribute('aria-pressed', 'false');
  });

  chatTab.addEventListener('click', () => {
    chatTab.classList.add('active', 'bg-blue-500', 'text-white');
    statsTab.classList.remove('active', 'bg-blue-500', 'text-white');
    chatView.classList.remove('hidden');
    statsView.classList.add('hidden');
    chatTab.setAttribute('aria-pressed', 'true');
    statsTab.setAttribute('aria-pressed', 'false');

    // Initialize dropdowns if we have model data
    if (modelData.length > 0) {
      // Reset all dropdowns
      creatorDropdown.empty();
      modelDropdown.empty();
      versionDropdown.empty();
      providerDropdown.empty();

      // Re-initialize select2 for all dropdowns
      creatorDropdown.select2({
        placeholder: "Select a creator...",
        allowClear: true
      });
      modelDropdown.select2({
        placeholder: "Select a model...",
        allowClear: true
      }).prop('disabled', true);
      versionDropdown.select2({
        placeholder: "Select a version...",
        allowClear: true
      }).prop('disabled', true);
      providerDropdown.select2({
        placeholder: "Select a provider with pricing...",
        allowClear: true
      }).prop('disabled', true);

      // Populate creator dropdown
      populateCreatorDropdown();
    }
  });

  // Initialize model data when page loads (no API key required)
  fetchModelData();
});
