// OpenRouter Model Selection and Chat Interface

document.addEventListener('DOMContentLoaded', () => {
  // DOM Element References
  const apiKey = document.getElementById('api-key');
  const saveKeyBtn = document.getElementById('save-key');
  const statsTab = document.getElementById('stats-tab');
  const chatTab = document.getElementById('chat-tab');
  const statsView = document.getElementById('stats-view');
  const chatView = document.getElementById('chat-view');

  // Model Selection Dropdowns
  const creatorDropdown = document.getElementById('creator-dropdown');
  const modelDropdown = document.getElementById('model-dropdown');
  const versionDropdown = document.getElementById('version-dropdown');
  const providerDropdown = document.getElementById('provider-dropdown');

  // Model Details Elements
  const pricingPrompt = document.getElementById('prompt-price');
  const pricingCompletion = document.getElementById('completion-price');
  const modelDescription = document.getElementById('model-description');

  // Fetch and process model data
  let modelData = [];

  async function fetchModelData() {
    try {
      const response = await fetch('fetchmodelresponse.json');
      const data = await response.json();
      modelData = data.data;
      populateCreatorDropdown();
    } catch (error) {
      console.error('Error fetching model data:', error);
    }
  }

  function populateCreatorDropdown() {
    const creators = [...new Set(modelData.map(model => model.author))];
    creators.sort();

    creatorDropdown.innerHTML = '<option value="">Select a creator...</option>';
    creators.forEach(creator => {
      const option = document.createElement('option');
      option.value = creator;
      option.textContent = creator;
      creatorDropdown.appendChild(option);
    });

    creatorDropdown.addEventListener('change', handleCreatorSelection);
  }

  function handleCreatorSelection() {
    const selectedCreator = creatorDropdown.value;
    
    // Reset subsequent dropdowns
    modelDropdown.innerHTML = '<option value="">Select a model...</option>';
    versionDropdown.innerHTML = '<option value="">Select a version...</option>';
    providerDropdown.innerHTML = '<option value="">Select a provider...</option>';
    
    // Disable dropdowns
    modelDropdown.disabled = true;
    versionDropdown.disabled = true;
    providerDropdown.disabled = true;

    if (!selectedCreator) return;

    // Filter models by creator
    const creatorModels = modelData.filter(model => model.author === selectedCreator);
    const uniqueModels = [...new Set(creatorModels.map(model => model.name))];
    
    uniqueModels.sort();
    modelDropdown.innerHTML = '<option value="">Select a model...</option>';
    uniqueModels.forEach(modelName => {
      const option = document.createElement('option');
      option.value = modelName;
      option.textContent = modelName;
      modelDropdown.appendChild(option);
    });

    modelDropdown.disabled = false;
    modelDropdown.addEventListener('change', handleModelSelection);
  }

  function handleModelSelection() {
    const selectedModel = modelDropdown.value;
    
    // Reset subsequent dropdowns
    versionDropdown.innerHTML = '<option value="">Select a version...</option>';
    providerDropdown.innerHTML = '<option value="">Select a provider...</option>';
    
    // Disable dropdowns
    versionDropdown.disabled = true;
    providerDropdown.disabled = true;

    if (!selectedModel) return;

    // Filter versions for the selected model
    const modelVersions = modelData.filter(model => model.name === selectedModel);
    const uniqueVersions = [...new Set(modelVersions.map(model => model.endpoint?.model_variant_slug || model.slug))];
    
    uniqueVersions.sort();
    versionDropdown.innerHTML = '<option value="">Select a version...</option>';
    uniqueVersions.forEach(version => {
      const option = document.createElement('option');
      option.value = version;
      option.textContent = version.split(':')[1] || 'standard';
      versionDropdown.appendChild(option);
    });

    versionDropdown.disabled = false;
    versionDropdown.addEventListener('change', handleVersionSelection);
  }

  function handleVersionSelection() {
    const selectedVersion = versionDropdown.value;
    
    // Reset provider dropdown
    providerDropdown.innerHTML = '<option value="">Select a provider...</option>';
    
    // Disable provider dropdown
    providerDropdown.disabled = true;

    if (!selectedVersion) return;

    // Filter providers for the selected version
    const versionProviders = modelData.filter(model => 
      (model.endpoint?.model_variant_slug === selectedVersion) || 
      (model.slug === selectedVersion)
    );

    const uniqueProviders = [...new Set(versionProviders.map(model => model.endpoint?.provider_name))];
    
    uniqueProviders.sort();
    providerDropdown.innerHTML = '<option value="">Select a provider...</option>';
    uniqueProviders.forEach(provider => {
      const option = document.createElement('option');
      option.value = provider;
      option.textContent = provider;
      providerDropdown.appendChild(option);
    });

    providerDropdown.disabled = false;
    providerDropdown.addEventListener('change', handleProviderSelection);
  }

  function handleProviderSelection() {
    const selectedCreator = creatorDropdown.value;
    const selectedModel = modelDropdown.value;
    const selectedVersion = versionDropdown.value;
    const selectedProvider = providerDropdown.value;

    if (!selectedCreator || !selectedModel || !selectedVersion || !selectedProvider) return;

    // Find the specific model entry
    const selectedModelEntry = modelData.find(model => 
      model.author === selectedCreator && 
      model.name === selectedModel && 
      ((model.endpoint?.model_variant_slug === selectedVersion) || (model.slug === selectedVersion)) &&
      model.endpoint?.provider_name === selectedProvider
    );

    if (selectedModelEntry) {
      // Update pricing info
      const pricing = selectedModelEntry.endpoint?.pricing || { prompt: '-', completion: '-' };
      pricingPrompt.textContent = `Prompt Price: $${pricing.prompt} per token`;
      pricingCompletion.textContent = `Completion Price: $${pricing.completion} per token`;

      // Update model description
      modelDescription.textContent = selectedModelEntry.description || 'No description available.';
    }
  }

  // Tab switching logic
  statsTab.addEventListener('click', () => {
    statsTab.classList.add('active');
    chatTab.classList.remove('active');
    statsView.classList.add('active');
    chatView.classList.remove('active');
  });

  chatTab.addEventListener('click', () => {
    chatTab.classList.add('active');
    statsTab.classList.remove('active');
    chatView.classList.add('active');
    statsView.classList.remove('active');
  });

  // Initialize
  fetchModelData();
});
